1: vue-cli脚手架初始化项目
2：node + webpack + 淘宝镜像

node_moduel文件夹：项目依赖
    例如：babel翻译官：es6语法翻译成es5

public文件夹：一般放置一些静态资源（图片），需要注意，放在public中的静态资源，webpack进行打包时会原封不动打包到dist文件夹中。（不会当作模块打包到js文件中）

src文件夹（程序员代码文件夹）：
    assets文件夹：一般放置静态资源（多个组件共用的静态资源），放置在这里的静态资源，webpack打包时，会把静态资源当作一个模块打包到js文件里
    components文件夹：一般放置的是非路由组件（或者全局组件）
    App.vue：唯一的根组件，Vue当中的组件（.vue）
    main.js：程序入口文件，也是整个程序当中最先执行的文件

.gitgnore：git忽略文件，一般不碰

babel.config.js：配置文件（babel相关）

package.json：记录项目信息，认为是项目的身份证（项目中的依赖，怎么运行）

package-lock.json：缓存性的文件

README.md

2：项目的其他配置

2.1 项目运行起来是浏览器自动打开
    ---package.json
     "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },

2.2 eslint校验功能关闭
---在根目录下创建一个vue.config.js
比如：申明变量未使用都会报错

2.3src文件夹简写方法
jsconfig.json配置别名@提示
{
  "compilerOptions": {
    "target": "es5",
    "module": "esnext",
    "baseUrl": "./",
    "moduleResolution": "node",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "lib": [
      "esnext",
      "dom",
      "dom.iterable",
      "scripthost"
    ]
  },
  "exclude": [
    "node_module",
    "dist"
  ]
}

3.项目路由的分析
前端所谓的路由：KV键值对。
key：URL（地址栏中的路径）
valve：相应的路由组件
本项目（可能）是上中下结构

路由组件：
中间部分HOME首页的路由组件、SEARCH搜索路由组件
上下部分都不是路由组件
    其中FOOTER在登录、注册页没有，其他（搜索，首页）页面有
    HEADER都有

4.完成非路由组件（HEADER，FOOTER）
在咱们的项目中不再以html+css为主，主要搞业务、逻辑
在开发项目的时候：
1：书写静态页面（HTML+CSS）
2：拆分组件
3：获取服务器的数据动态展示
4：完成相应的动态业务逻辑

注意：1.创建组建的时候，组件结构+组件的样式+图片资源
2.采用less样式，浏览器不识别less样式，需要通过less、less-loader进行处理,将less样式转换成css，浏览器才能识别
也就是在style标签身上加上lang=less

4.1使用组件的步骤（非路由组件）
-创建或者定义
-引入
-注册
-使用

5）路由组件的搭建
vue-rooter(一定使用这个组件)
在上面分析的时候，路由组件应该有四个：Home，Search，Login，Register
-components文件夹：经常放置的非路由组件（共用全局组件）
-pages|views文件夹：经常放置路由组件

5.1配置路由
项目中配置的路由一般放置在router文件夹中

5.2总结
路由组件与非路由组件的区别：
1.放置文件夹不同，路由组件放置在pages|views中，非路由组件一般放置在components文件夹中
2.路由组件一般需要在router文件夹中进行注册（使用的即为组件的名字），非路由组件在使用时一般都是以标签的形式使用
3.注册完路由，不管是路由组件还是非路由组件身上都有$route\$router属性

$route:一般获取路由信息【路径，query，params等】
$router:一般进行编程式导航进行路由跳转【push|replace（能不能记住历史记录）】

5.3路由的跳转
有两种形式：声明式导航router-link，可以进行路由的跳转
编程式导航push|replace,可以进行路由跳转（更全能，可以书写业务后再跳转）

6）Footer组件显示与隐藏
显示或者隐藏：v-if（操作dom消耗性能）|v-show
Footer组件：在Home、Search显示Footer组件
Footer组件：在登录，注册时隐藏

6.1我们可以根据组件身上的￥route获取当前路由的信息，通过路由路径判断Footer显示与隐藏。
6.2配置路由的时候，可以给路由添加路由元信息【meta】，路由需要配置对象，它的key不能瞎写

8）路由传参
8.1路由跳转方式
声明式导航。编程式导航

8.2路由传参，参数有几种写法
params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位
query参数：不属于路径当中的一部分，类似于ajax中的queryString /home?k=v&kv=,不需要占位

路由传参题目：
1.路由传递参数（对象写法）path是否可以结合params参数使用
答：不可以，得将path写法改成name写法
2.如何制定params参数可传可不传
答：配置路由的时候如果站位了（也就是写上了params参数），但是路由跳转的时候你选择不传递，路径会出现问题.
配置路由时，在站位后面加上？，就可以指定可传可不传
3.params参数可以传递也可以不传递，但是如果传递的是空串
答：使用undefined解决
4.路由组件能不能传递props数据
答：可以，三种写法：字符串，对象，函数

重写push和replace方法
为什么编程式导航会出现多次执行跳转报错的问题
通过给push方法传递相应的成功和失败的回调函数，可以解决这个问题（治标不治本）

this是指向当前组件实例的
this.$router属性：当前这个书香，属性值是VueRouter类的一个实例，当在入口文件注册路由时，给组件实例添加了$router和$route
push是Vue

Home组件拆分
--完成静态页面
--拆分出静态组件进行展示
--获取服务器的数据进行展示
--动态业务

三级联动组件完成
---由于三级联动在多个路由中都要使用，所以设置为全局组件
    只需要注册一次，就可以多次使用

POSTMAN测试接口
--200代表通过
--接口前缀都有api

axios二次封装
XMLHttpRequest、fetch、JQ、axios
为什么需要二次封装
请求拦截器，响应拦截器
可以在发请求之前处理一些业务
当服务器数据返回以后，可以处理一些事情

在项目中经常出现API文件夹【关于axios】
接口当中路径经常带有api

接口统一管理
如果项目小，就可以直接在组件的生命周期中发送请求
项目大：axios.get('xxx')

跨域问题（面试问题）
什么是跨域：协议，域名，端口号不同的请求，称之为跨域
http://localhost:8080/  ---前端本地服务器
http://gmall-h5-api.atguigu.cn  ---后台服务器

解决办法：JSONP CROS 代理

nprogress进度条使用

vuex状态管理库
vuex是官方提供的一个插件，状态管理库，集中式管理数数据
并不是全部项目都需要（大项目）
Vuex:  state
       mutations
       actions
       getters
       modules

Vuex基本使用
可以模块化

10：完成TypeNav三级联动展示数据业务
因为是全局组件，先将他放到components文件夹当中

通过js控制二三级商品分类的显示与隐藏
最开始的时候，是通过css样式display：block|none显示与隐藏二三级商品分类

防抖与节流
节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会出发回调，把频繁触发变为少量触发
防抖：前面的所有的触发都被取消，最后一次执行在规定时间之后才会触发，也就是说如果连续快速的触发 只会执行一次
使用lodash插件:里面封装函数的防抖与节流的业务【闭包+延迟期】
lodash函数库对外暴露_函数

三级联动组建的路由跳转与传递参数
三级联动用户可以点击123级分类，当点击时Home模块跳转到Search模块，一级会把用户选中的产品在路由跳转的时候进行传递参数
使用声明式出现卡顿现象
编程式导航又会响应太多函数
所以采用事件的委派
路由跳转：声明式导航，编程式导航

三级分类列表优化
将读取接口数据的挂载函数卸载app.vue

合并参数
因为点击typenav中的值跳转到search页面只能读取query中传的id和name
而点击搜索按键只能传递输入框中输入的params参数key

开发home首页中的listContainer组件和Floor组件
服务器返回的数据（接口）只有商品分类菜单数据，对于listContainer组件和Floor组件数据没有提供
mockjs模拟数据，mock假数据不会和服务器进行任何通信，所以会拦截ajax请求
准备mock文件夹
准备json数据,不能留有空格
将所需要的图片放入public文件夹中，打包时就放入dist中
开始mock虚拟数据,创建mockServe.js文件
把mockServe文件放在main.js中引入

轮播图（swiper使用）
安装插件5版本
引包和样式
最好的解决办法：watch数据监听+nextTick

开发floor组件
拿数据的步骤，先写api然后用仓库捞数据，最后通过state展示数据
得在home中发，因为需要v-for遍历floor组件才能生成多个floor标签
需要父子通信：props父传子
自定义事件：@on @emit 可以实现子给父传数据
全局事件总线：$bus 全能 
pubsub也算 全能
插槽
vuex

把首页的轮播图拆分为共用的全局组件
可以复用组件

search组件开发
1.先静态页面+静态组件拆分出来
2.发请求(api)
3.vuex（actions，mutations，state）
4.组件获取仓库数据，动态展示数据

面包屑处理分类的操作
动态开发
编程式导航路由跳转

动态开发面包屑中关键字置空
兄弟组件通信
采用全局事件总线
这其中包括很多面包屑（关键字，属性值，还有更下面的数据）

排序操作
1是综合2是价格asc是升序desc是降序
示例：“1：desc”

order中的属性值有多少种写法
1：asc
1：desc
2：asc
2：desc
谁应该有类名：通过order属性值当中是包含1（综合）|包含2（价格）
可以用iconfont图标库生成

重点：分页器
先把它变成全局组件
为了防止数据很多
饿了吗ui可以直接分页器，先不用

分页器展示需要哪些数据
pageNo，当前在第几页
pageSize，每一页需要展示多少条数据
total，一共有多少数据
continues,代表连续页码数

开发详情页面
静态组件
发请求
vuex
动态展示
点击商品图片跳转到详情页面，并且带有params参数
滚动行为

放大镜效果实现

浏览器存储功能，HTML5中新增的
分为本地存储和会话存储（本地存储持久化的，会话存储会消失）
使用会话存储的方式加上query传参将detail中的数据传给添加成功页面
html5：
新增了一些标签：navi，footer
新增了一些css：transition，transform
新增了一些多媒体功能：canvas，video
新增了直播

购物车页面
还是老一套
因为传给购物车后需要将数据交给服务器，然后后端会写数据库，但是得不同的人对应不同的购物内容
因此在传递时，需要在detail中就加入唯一识别标识，通过uuid生成一个随机数，并且在请求头加入（node）
这时不能直接在detail组件中添加uuid函数，因为如果这样就会不断生成新的id
因此新建一个utils文件夹保存这个函数每次调用就不能更改，并且要一直保存在localstorage中，因为要一直保存用户数据

动态展示购物车信息

修改商品次数需要节流

今天写了全选的操作还有全部删除的操作
注意点：
  1.在actions的方法中dispatch其他actions中的方法，因为形参context中是一个小仓库，里面包含state等可以拿数据
  2.这种多次的请求服务器，需要返回正确或者错误，因此采用promise.all方法，里面是个数组
  3.每一次请求服务器都需要async和await等待
  4.可以通过event拿盒子中的数据

登陆和注册静态页面
assets文件夹中是所有组件共用的文件夹，打包后就会消失

注册的业务
验证先不处理
写接口

登陆的业务
数据库先存储注册的用户信息
登录时，后台为了区分你这个用户是谁，会发送token【令牌，唯一标识符】
前台需要持久化存储token【带着token向服务器要用户的数据】
像是前台自己生成的uuid，但是这个是服务器后端发过来的
登陆成功后跳转到首页时需要带着token向服务器发请求拿到用户的数据
然后在首页展示

但是vuex仓库存储数据不是持久化的，需要存储到localstorage，一直保存用户的token

这里的问题：
  1.首先发送请求给服务器拿到用户数据，但是请求中没有要求参数，所以又是在请求头中加入token，用来分辨用户
    我的理解：请求头中的token会被服务器识别？然后将token对应的用户信息返回
    这里的token是服务器发过来的每个用户的标识符，独一无二
    因为在封装axios的js文件中引入了store，因此可以用store中的数据，此时拿到token
  2.这里需要在按钮发登录请求时写上async和await，将其变成一个异步操作，这样就会等待promise回来，要不然首页依然不会有信息
  3.然后刷新后会没有信息，因为store中的数据是暂时存储的，所以需要将token存入localstorage中

此时还是存在如果没有token，promise会返回错误

还有就是现在只有在home的mounted中触发getUserINfo，其他页面刷新后就没有token
(如果把挂载放在app中还是会出现问题，因为app只会执行一次，但是刷新可以)
用户已经登陆就不应该再回登录页面了

引出导航守卫
比如：登陆后不应该进入登陆页面
全局守卫：前置守卫和后置守卫（项目中只要发生路有变化就能监听到）
路由独享守卫
组件内守卫

上述的问题解决了一部分，首先每个路由跳转的时候都会经过getuserInfo的操作
出现问题是因为user的token应该先将token置为空串然后再将localstorage中的token也清空

trade组件，首先还是发请求但是必须在用户登录时才可以出现在结算页面
请求返回的是用户的地址数组

今天完成了trade页面还是一样的三连环
然后在组件中回调，可能还需要使用mapstate来简化

提交订单
支付页面静态组件完成
trade页面的点击提交订单的按钮时，需要发一次请求
这次发请求不在vuex中
这里将所有的Api中的请求函数全部在mainjs中统一接收
所有的api都挂在了vue的原型对象上，跟$bus全局事件总线一样

query传参和params传参

生命周期函数不能async

使用组件库完成弹出微信支付
已经认识的组件库：
  React（Vue）:antd[PC] antd-mobile[移动端]
  Vue:ElementUI[PC] vant[移动端]
使用elementui，首先是按需引入
点击取消的时候会有promise报错
这里需要在$catch后面添加.catch抓住取消后的信息

个人中心二级路由搭建
首先应该重定向，让到达个人中心页面时就是我的订单二级路由展示
在展示个人购物清单时，每一单需要遍历，每一单可能购买了很多个商品，
每个商品后面的购买人是一样的所以并不需要多次展示，因此只需要展示第一个

面试时问是否封装过组件：分页器和日历
个人中心的分页器

解决问题：当未登陆时进入交易相关页面，应该将其重定向为登陆页面，
但是登陆完成后应该将其直接跳转到原来想去的页面

路由独享守卫，使得登陆后也不能直接去交易成功页面
使用组件内路由守卫（三个）

图片的懒加载

自定义插件的使用




